
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Обнаружение дорожных знаков с помощью Deep Learning - DataDeep Evil Twin</title>
  <meta name="author" content="Команда datadeep.ru">

  
  <meta name="description" content="Обнаружение дорожных знаков с помощью Deep learning">
  <meta name="keywords" content="machine learning, deep learning, computer vision">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://datadeep.ru/blog/2015/08/16/dietiektirovaniie-dorozhnykh-znakov-s-pomoshch'iu-deep-learning">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="DataDeep Evil Twin" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">DataDeep Evil Twin</a></h1>
  
    <h2>Sapere aude</h2>
  
</hgroup>

</header>
  <nav role="navigation">
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:datadeep.ru" />
    <input class="search" type="text" name="q" results="0" placeholder="Поиск"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Блог</a></li>
  <li><a href="/blog/archives">Архив блога</a></li>
  <li><a href="/about_blog">О блоге</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Обнаружение дорожных знаков с помощью Deep Learning</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-16T23:36:02+03:00'><span class='date'>16/08/2015</span> <span class='time'>23:36</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Команда блога DataDeep.ru не смогла остаться в стороне от <a href="https://meduza.io/news/2015/07/17/samoupravlyaemaya-mashina-google-popala-v-pervoe-dtp-s-postradavshimi">новости об аварии самоуправляемого автомобиля Google</a>, и поэтому я решил написать пост о своём опыте разработки системы для обнаружения дорожных знаков, основанной на машинном обучении. Такую систему вполне можно отнести к компонентам, которые используются как для разработки механизмов автономного упраления автомобилем, так и в современных системах помощи водителю :)</p>

<p><img src="/images/selfdrivingcar.jpg" width="768" height="576" title="Self-driving car" /></p>

<!-- more -->

<h2 id="section">Постановка задачи, описание данных</h2>

<p>Итак, мы хотим сделать приложение, которое будет максимально достоверно находить и выделять рамкой (region of interest, ROI) дорожные знаки на изображении, поступившем на вход. Сердцем метода, решающего эту задачу, будет, как не трудно предположить, машинное обучение. Для использования такого подхода необходимы тренировочные данные, в качестве которых будем использовать данные с соревнования <a href="http://benchmark.ini.rub.de/?section=gtsdb&amp;subsection=dataset">The German Traffic Sign Detection Benchmark</a>. Это соревнование по детектированию и определению категории дорожного знака, которое проводилось в 2013 году. В этих данных содержится информация о знаках из нескольких категорий, таких как предупреждающие, приоритета, запрещающие и предписывающие. Парным к нему является соревнование по распознаванию знаков The German Traffic Sign Recognition Benchmark, в котором алгоритм, построенный на основе глубоких нейронных сетей (deep learning), <a href="http://www.nytimes.com/2012/11/24/science/scientists-see-advances-in-deep-learning-a-part-of-artificial-intelligence.html?_r=0">превзошёл по точности распознавания уровень человека</a>.</p>

<p>Данные представляют собой 900 изображений размером $1360 \times 800$ в формате ppm, а также 1213 изображений дорожных знаков, взятых с этих картинок, размером от $16\times16$ до $128\times128$ в формате ppm.  Некоторые из больших изображений содержат один и более знак, в то время, как другие не содержат знаков вовсе. ROI задаётся с помощью четырёхмерного вектора с координатами прямоугольной рамки <script type="math/tex">(x_{min}, y_{min}, x_{max}, y_{max})</script>. Для всех 900 изображений заданы правильные ROI. Несколько примеров из данных:</p>

<p>Один дорожный знак:</p>

<p><img src="/images/0.jpg" title="Один знак" /></p>

<p>Два знака:</p>

<p><img src="/images/1.jpg" title="Два знака" /></p>

<p>Без знаков:</p>

<p><img src="/images/2.jpg" title="Без знаков" /></p>

<p>Таким образом, наша задача заключается в том, чтобы обучить алгоритм, который для входного изображения будет выдавать ноль или более четырёхмерных векторов по числу обнаруженных дорожных знаков.</p>

<h2 id="state-of-the-art-">Обзор <em>state of the art</em> подходов</h2>

<p>Начиная примерно с 2012 года, когда на очень известном в сообществе computer vision соревновании по распознаванию изображений ImageNet победила команда университета Торонто под руководством Джеффри Хинтона, показав при этом значительный отрыв в точности от других команд, state of the art методом для распознавания изображений считается использование глубоких свёрточных нейронных сетей (Convolutional neural network, CNN), которые, в свою очередь, являются представителем класса алгоритмов машинного обучения deep learning (глубокое или, если угодно, глубинное обучение). Очень многие лучшие на сегодняшний день системы машинного зрения основаны на CNN, например <a href="https://research.facebook.com/publications/480567225376225/deepface-closing-the-gap-to-human-level-performance-in-face-verification/">система распознавания лиц от Facebook</a> (к слову, глава Facebook AI Research Ян Лекун является одним из пионеров в исследовании CNN и deep learning).</p>

<p>В области детектирования предметов на изображении одним из самых эффективных является метод <em>Regions with CNN features</em> или <em>R-CNN</em>, представленный в 2014 году. Этот метод можно разделить на следующие этапы:</p>

<ol>
  <li>Определение областей изображения, которые могут содержать интересующие нас объекты, с помощью алгоритма <em>Selective search</em>;</li>
  <li>Выделение из полученных областей признаков, используя свёрточную нейронную сеть;</li>
  <li>Эти признаки подаются на вход SVM (Support vectors machine), которая классифицирут объект.</li>
</ol>

<p>Существуют и другие успешные методы дектирования, основанные на CNN, например <a href="http://arxiv.org/abs/1312.6229">построение регрессии</a> для нахождения четырёхмерного вектора ROI (т.е. на последнем уровне CNN находятся не вероятности, а целые значения). Однако, идея алгоритма, который мы будем строить, вдохновлена в первую очередь R-CNN, благодаря его простоте и эффективности, и реализует три его этапа, хотя имеет ряд значительных отличий.</p>

<h2 id="section-1">Описание метода</h2>

<p>Перед тем, как описать структуру метода для детектирования дорожных знаков на изображении, скажу пару слов о технологиях, которые будут использованы. В качестве языка программирования используется python, так как для него есть API всех необходимых библиотек, и в данном случае нам больше важна гибкость и лёгкость прототипирования, чем скорость работы приложения.</p>

<p>Вся работа со свёрточными нейронными сетями ведётся с помощью изумительной библиотеки <a href="http://caffe.berkeleyvision.org/">Caffe</a>. Она позволяет конструировать, обучать и применять CNN, содержит state of the art виды слоёв и методы тренировки сети, обрабатывает данные в различных форматах (в том числе HDF5), позволяет обучать сети на графическом процессоре (GPU) с использованием CUDA, имеет обёртку для python pycaffe. Для caffe есть хранилище model zoo, в котором содержаться обученные модели, которые можно использовать для своих задач. Также хочется отметить хорошие туториалов и большое сообщество. Архитектура нейронных сетей и параметры метода обучения задаются в Caffe в файлах <a href="https://developers.google.com/protocol-buffers/docs/overview">формата prototxt</a>.</p>

<p>Для обработки изображений используется библиотека OpenCV, которая, я думаю, не нуждается в дальнейшем представлении.</p>

<h3 id="mser">Детектор MSER</h3>

<p>Приступим непосредственно к методу решения задачи. На первом этапе будем определять области входного изображения, которые потенциально могут содержать дорожный знак. Для этого было рассмотрено несколько детекторов (в частности selective search из R-CNN, который не смог хорошо выделить области со знаками). Метрикой качества служило среднее евкидово расстояние между настоящим ROI на изображениях из тренировочных данных и ближайшим к нему ROI, полученным с помощью детектора.   Лучше всего себя показал метод <a href="https://en.wikipedia.org/wiki/Maximally_stable_extremal_regions">MSER</a> (maximally stable extremal regions). Из выделенных MSER областей отбирались те, в которых длина и ширина лежат в пределах от 16 до 128 и их соотношение не превышает 1.5 (т.е. более-менее близки по форме к квадрату). Таким образом, мы получаем набор областей, в которых может содержаться один дорожный знак.</p>

<h3 id="main-cnn">Main CNN</h3>

<p>На следующем этапе алгоритма для определения того, содержит ли область изображения из предыдущего этапа знак, будем применять классификатор. В этом качестве выступит представитель класса методов deep learning — глубокая свёрточная нейронная сеть. Ей на вход будет поступать изображение, а на выходе будут две вероятности, сумма которых равна 1: того, что изображение содержит и не содержит дорожный знак. Архитектура нейронной сети, которую мы будем использовать, сходна c архитектурой весьма эффективной сети <em>Network in network</em> (NIN), которая хорошо себя показала в 2014 году в конкурсе <a href="http://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10</a> (определение, к какой из 10 категорий принадлежит изображение).</p>

<p>На вход нейронная сеть получает RGB изображение размером $32\times32$, которое предварительно преобразуется в такой формат, если нужно. Рассмотрим вкратце слои сети.</p>

<ul>
  <li><em>Свёрточный слой</em> (CONV) — как видно из названия, является основной частью CNN. Он реализует обычную операцию свёртки: мы идём по изображению скользящим окном, перемножаем значения в окне с заданными весами, а затем всё складываем. Наборов весов может быть несколько. Проиллюстрируем то, что делает свёрточный слой:</li>
</ul>

<p>[картинка свёртки]</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)"><em>Rectified linear unit</em></a> (RELU) — слой, в котором нет какой-то сложной математики и, как следствие, настраиваемых параметров. Он служит для того, чтобы получить нелинейность. К каждому входному значению этого слоя применяется функция:</li>
</ul>

<p>[картинка ReLU]</p>

<p>Это то, что происходит в нейроне, так называемая <em>activasion function</em>. В “классических” нейронных сетях для этого используется сигмоидная функция или тангенс. Однако в последнее время эмпирически было установлено, что простая функция RELU оказывается очень эффективной.
* <em>Pooling</em> (POOL) — служит для уменьшения размерности. Входной двумерный массив делится на сектора, в зависимости от параметров, и в каждом из них происходит максимизация или усреднение (два самых распространённых вида pooling’а).
* <em>Dropout</em> (DROP) — недавно открытый, очень эффективный и простой способ регуляризации (т.е. снижения эффекта переобучения). Его суть заключвется в том, что с заданной вероятностью нейроны сети отключаются и не участвуют в текущей итерации обучения.</p>

<p>Архитектура всей сети представляет собой 3 больших последовательно соединённых слоя, каждый из которых состоит из [CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; POOL -&gt; DROP]. На самом последнем слое мы получаем две вероятности. Назовём эту сеть <em>Main CNN</em>. Ниже приведено полное описание сети в формате prototxt, которое применятся для её обучения с помощью Caffe.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (signet_nin_finetune_deploy.html)</span> <a href="/downloads/code/signet_nin_finetune_deploy.html">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
<span class="line-number">104</span>
<span class="line-number">105</span>
<span class="line-number">106</span>
<span class="line-number">107</span>
<span class="line-number">108</span>
<span class="line-number">109</span>
<span class="line-number">110</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
<span class="line-number">113</span>
<span class="line-number">114</span>
<span class="line-number">115</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span>
<span class="line-number">119</span>
<span class="line-number">120</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
<span class="line-number">123</span>
<span class="line-number">124</span>
<span class="line-number">125</span>
<span class="line-number">126</span>
<span class="line-number">127</span>
<span class="line-number">128</span>
<span class="line-number">129</span>
<span class="line-number">130</span>
<span class="line-number">131</span>
<span class="line-number">132</span>
<span class="line-number">133</span>
<span class="line-number">134</span>
<span class="line-number">135</span>
<span class="line-number">136</span>
<span class="line-number">137</span>
<span class="line-number">138</span>
<span class="line-number">139</span>
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>
<span class="line-number">143</span>
<span class="line-number">144</span>
<span class="line-number">145</span>
<span class="line-number">146</span>
<span class="line-number">147</span>
<span class="line-number">148</span>
<span class="line-number">149</span>
<span class="line-number">150</span>
<span class="line-number">151</span>
<span class="line-number">152</span>
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>
<span class="line-number">156</span>
<span class="line-number">157</span>
<span class="line-number">158</span>
<span class="line-number">159</span>
<span class="line-number">160</span>
<span class="line-number">161</span>
<span class="line-number">162</span>
<span class="line-number">163</span>
<span class="line-number">164</span>
<span class="line-number">165</span>
<span class="line-number">166</span>
<span class="line-number">167</span>
<span class="line-number">168</span>
<span class="line-number">169</span>
<span class="line-number">170</span>
<span class="line-number">171</span>
<span class="line-number">172</span>
<span class="line-number">173</span>
<span class="line-number">174</span>
<span class="line-number">175</span>
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>
<span class="line-number">179</span>
<span class="line-number">180</span>
<span class="line-number">181</span>
<span class="line-number">182</span>
<span class="line-number">183</span>
<span class="line-number">184</span>
<span class="line-number">185</span>
<span class="line-number">186</span>
<span class="line-number">187</span>
<span class="line-number">188</span>
<span class="line-number">189</span>
<span class="line-number">190</span>
<span class="line-number">191</span>
<span class="line-number">192</span>
<span class="line-number">193</span>
<span class="line-number">194</span>
<span class="line-number">195</span>
<span class="line-number">196</span>
<span class="line-number">197</span>
<span class="line-number">198</span>
<span class="line-number">199</span>
<span class="line-number">200</span>
<span class="line-number">201</span>
<span class="line-number">202</span>
<span class="line-number">203</span>
<span class="line-number">204</span>
<span class="line-number">205</span>
<span class="line-number">206</span>
<span class="line-number">207</span>
<span class="line-number">208</span>
<span class="line-number">209</span>
<span class="line-number">210</span>
<span class="line-number">211</span>
<span class="line-number">212</span>
<span class="line-number">213</span>
<span class="line-number">214</span>
<span class="line-number">215</span>
<span class="line-number">216</span>
<span class="line-number">217</span>
<span class="line-number">218</span>
<span class="line-number">219</span>
<span class="line-number">220</span>
<span class="line-number">221</span>
<span class="line-number">222</span>
<span class="line-number">223</span>
<span class="line-number">224</span>
<span class="line-number">225</span>
<span class="line-number">226</span>
<span class="line-number">227</span>
<span class="line-number">228</span>
<span class="line-number">229</span>
<span class="line-number">230</span>
<span class="line-number">231</span>
<span class="line-number">232</span>
<span class="line-number">233</span>
<span class="line-number">234</span>
<span class="line-number">235</span>
<span class="line-number">236</span>
<span class="line-number">237</span>
<span class="line-number">238</span>
<span class="line-number">239</span>
<span class="line-number">240</span>
<span class="line-number">241</span>
<span class="line-number">242</span>
<span class="line-number">243</span>
<span class="line-number">244</span>
<span class="line-number">245</span>
<span class="line-number">246</span>
<span class="line-number">247</span>
<span class="line-number">248</span>
<span class="line-number">249</span>
<span class="line-number">250</span>
<span class="line-number">251</span>
<span class="line-number">252</span>
<span class="line-number">253</span>
<span class="line-number">254</span>
<span class="line-number">255</span>
<span class="line-number">256</span>
<span class="line-number">257</span>
<span class="line-number">258</span>
<span class="line-number">259</span>
<span class="line-number">260</span>
<span class="line-number">261</span>
<span class="line-number">262</span>
<span class="line-number">263</span>
<span class="line-number">264</span>
<span class="line-number">265</span>
<span class="line-number">266</span>
<span class="line-number">267</span>
<span class="line-number">268</span>
<span class="line-number">269</span>
<span class="line-number">270</span>
<span class="line-number">271</span>
<span class="line-number">272</span>
<span class="line-number">273</span>
<span class="line-number">274</span>
<span class="line-number">275</span>
<span class="line-number">276</span>
<span class="line-number">277</span>
<span class="line-number">278</span>
<span class="line-number">279</span>
<span class="line-number">280</span>
<span class="line-number">281</span>
<span class="line-number">282</span>
<span class="line-number">283</span>
<span class="line-number">284</span>
<span class="line-number">285</span>
<span class="line-number">286</span>
<span class="line-number">287</span>
<span class="line-number">288</span>
<span class="line-number">289</span>
<span class="line-number">290</span>
<span class="line-number">291</span>
<span class="line-number">292</span>
<span class="line-number">293</span>
<span class="line-number">294</span>
<span class="line-number">295</span>
<span class="line-number">296</span>
<span class="line-number">297</span>
<span class="line-number">298</span>
<span class="line-number">299</span>
<span class="line-number">300</span>
<span class="line-number">301</span>
<span class="line-number">302</span>
<span class="line-number">303</span>
<span class="line-number">304</span>
<span class="line-number">305</span>
<span class="line-number">306</span>
<span class="line-number">307</span>
<span class="line-number">308</span>
<span class="line-number">309</span>
<span class="line-number">310</span>
<span class="line-number">311</span>
<span class="line-number">312</span>
<span class="line-number">313</span>
<span class="line-number">314</span>
<span class="line-number">315</span>
<span class="line-number">316</span>
<span class="line-number">317</span>
<span class="line-number">318</span>
<span class="line-number">319</span>
<span class="line-number">320</span>
<span class="line-number">321</span>
</pre></td><td class="code"><pre><code class="html"><span class="line">name: &quot;SigNet_NIN_FineTune_Deploy&quot;
</span><span class="line">input: &quot;data&quot;
</span><span class="line">input_dim: 1
</span><span class="line">input_dim: 3
</span><span class="line">input_dim: 32
</span><span class="line">input_dim: 32
</span><span class="line">layers {
</span><span class="line">  name: &quot;conv1&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;data&quot;
</span><span class="line">  top: &quot;conv1&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1.
</span><span class="line">  weight_decay: 0.
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    pad: 2
</span><span class="line">    kernel_size: 5
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu1&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;conv1&quot;
</span><span class="line">  top: &quot;conv1&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp1&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;conv1&quot;
</span><span class="line">  top: &quot;cccp1&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 160
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp1&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp1&quot;
</span><span class="line">  top: &quot;cccp1&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp2&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;cccp1&quot;
</span><span class="line">  top: &quot;cccp2&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 96
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp2&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp2&quot;
</span><span class="line">  top: &quot;cccp2&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;pool1&quot;
</span><span class="line">  type: POOLING
</span><span class="line">  bottom: &quot;cccp2&quot;
</span><span class="line">  top: &quot;pool1&quot;
</span><span class="line">  pooling_param {
</span><span class="line">    pool: MAX
</span><span class="line">    kernel_size: 3
</span><span class="line">    stride: 2
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;drop3&quot;
</span><span class="line">  type: DROPOUT
</span><span class="line">  bottom: &quot;pool1&quot;
</span><span class="line">  top: &quot;pool1&quot;
</span><span class="line">  dropout_param {
</span><span class="line">    dropout_ratio: 0.5
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;conv2&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;pool1&quot;
</span><span class="line">  top: &quot;conv2&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1.
</span><span class="line">  weight_decay: 0.
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    pad: 2
</span><span class="line">    kernel_size: 5
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu2&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;conv2&quot;
</span><span class="line">  top: &quot;conv2&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp3&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;conv2&quot;
</span><span class="line">  top: &quot;cccp3&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp3&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp3&quot;
</span><span class="line">  top: &quot;cccp3&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp4&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;cccp3&quot;
</span><span class="line">  top: &quot;cccp4&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp4&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp4&quot;
</span><span class="line">  top: &quot;cccp4&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;pool2&quot;
</span><span class="line">  type: POOLING
</span><span class="line">  bottom: &quot;cccp4&quot;
</span><span class="line">  top: &quot;pool2&quot;
</span><span class="line">  pooling_param {
</span><span class="line">    pool: AVE
</span><span class="line">    kernel_size: 3
</span><span class="line">    stride: 2
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;drop6&quot;
</span><span class="line">  type: DROPOUT
</span><span class="line">  bottom: &quot;pool2&quot;
</span><span class="line">  top: &quot;pool2&quot;
</span><span class="line">  dropout_param {
</span><span class="line">    dropout_ratio: 0.5
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;conv3&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;pool2&quot;
</span><span class="line">  top: &quot;conv3&quot;
</span><span class="line">  blobs_lr: 1.
</span><span class="line">  blobs_lr: 2.
</span><span class="line">  weight_decay: 1.
</span><span class="line">  weight_decay: 0.
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    pad: 1
</span><span class="line">    kernel_size: 3
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu3&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;conv3&quot;
</span><span class="line">  top: &quot;conv3&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp5&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;conv3&quot;
</span><span class="line">  top: &quot;cccp5&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp5&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp5&quot;
</span><span class="line">  top: &quot;cccp5&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp6_signet&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;cccp5&quot;
</span><span class="line">  top: &quot;cccp6_signet&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 1
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 2
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp6_signet&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp6_signet&quot;
</span><span class="line">  top: &quot;cccp6_signet&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;pool3_signet&quot;
</span><span class="line">  type: POOLING
</span><span class="line">  bottom: &quot;cccp6_signet&quot;
</span><span class="line">  top: &quot;pool3_signet&quot;
</span><span class="line">  pooling_param {
</span><span class="line">    pool: AVE
</span><span class="line">    kernel_size: 8
</span><span class="line">    stride: 1
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;prob&quot;
</span><span class="line">  type: SOFTMAX
</span><span class="line">  bottom: &quot;pool3_signet&quot;
</span><span class="line">  top: &quot;prob&quot;
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Для того, чтобы обучить всё эту сеть будем использовать стандартный метод оптимизации <a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent">Batch stochastic gradient descent</a> с уменьшением параметра learning rate в 10 раз каждые 1000 шагов, начальный learning rate — 0.000001. Кроме того, применим метод Momentum Нестерова с параметром 0.9. В качестве регуляризации будем использовать Weight decay с параметром 0.0001. Обучение будет остановлено или при достижении максимального количества итераций, или при малом изменении функции потерь. Prototxt файл со всеми параметрами оптимизации, который используется в Caffe:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (signet_nin_finetune_solver.html)</span> <a href="/downloads/code/signet_nin_finetune_solver.html">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="html"><span class="line">net: &quot;/home/andrew/Projects/GTSDB/mark_III/model/signet_nin_finetune_train_val.prototxt&quot;
</span><span class="line">test_iter: 100
</span><span class="line">test_interval: 1000
</span><span class="line">base_lr: 0.000001
</span><span class="line">momentum: 0.9
</span><span class="line">weight_decay: 0.0001
</span><span class="line">lr_policy: &quot;step&quot;
</span><span class="line">gamma: 0.1
</span><span class="line">stepsize: 1000
</span><span class="line">display: 100
</span><span class="line">max_iter: 50000
</span><span class="line">snapshot: 1000
</span><span class="line">snapshot_prefix: &quot;/home/andrew/Projects/GTSDB/mark_III/model/caffemodel/signet_nin_finetune_finetune_3&quot;
</span><span class="line">solver_mode: GPU
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Для ускорения обучения будем применять подход <em>Fine-tuning</em>: веса нейронной сети инициализируются предобученными для другой (но похожей) задачи. Мы используем веса, которые были обучены авторами NIN для задачи CIFAR-10.</p>

<h3 id="features-learning-cnn">Features learning CNN</h3>

<p>Итак, с помощью описанной выше CNN мы отберём области изображения, скорее всего содержащие знак (т.е. те, для которых вероятность наличия знака, выданная сетью, больше порога 0.5). Для того, чтобы улучшить качество распознавания, построим поверх нейронной сети ещё один классификатор. Для этого будем использовать CNN, аналогичную той, которую мы уже построили, только без последнего слоя вероятностей. Если посмотреть на параметры в описании архитектуры используемой CNN, то от туда можно понять, что новая сеть будет выдавать на выходе вектор размерности 128. Назовём её <em>Features learning CNN</em>. В качестве весов она использует натренированные веса Main CNN. Features learning CNN мы будем применять к областям изображений, которые по мнению Main CNN содержат дорожный знак.  Мы получим 128-размерный вектор признаков, который будем “скармливать” машине опорных векторов (SVM) с полиномиальным ядром степени 2 и параметром регуляризации 0.1. Таким образом, полный алгоритм представляет собой ансамбль: MSER -&gt; Main CNN -&gt; Features learning CNN -&gt; SVM.</p>

<h3 id="bootstrap">Bootstrap</h3>

<p>Для того, чтобы нарисовать ROI, содержащую дорожный знак, нам остался ещё один шаг. В силу особенностей метода MSER может получиться ситуация, когда для одного знака получается несколько очень близко расположенных рамок (т.е. областей изображения, отобранных на предыдущем этапе). Объединив такие рамки в одну (взяв наибольшую из них), мы получим финальный ROI.</p>

<h2 id="section-2">Применение метода</h2>

<p>Теперь опишем то, как обучался алгоритм и что из этого вышло. Прежде всего, нам необходимы тренировочные данные для Main CNN. Разделим имеющиеся в нашем распоряжении 900 изображений на 600 тренировочных и 300 тестовых. В исходных данных уже есть изображения дорожных знаков, т.е. положительные прецеденты, однако нет отрицательных, т.е. изображений без знаков. Для того, чтобы получить эти данные, используем следующую процедуру: к каждому изображению из тренировочных данных применяется MSER и отбираются те его области, которые похожи по размерам на ROI (см. выше), не пересекаются с настоящим ROI, но при этом лежат относительно “не далеко” от него. Последний пункт нужен, т.к. CNN будет хорошо “отличать” дорожный знак от, например, неба или асфальта, но плохо от окна, фары машины, листвы и т.д., т.е. от объектов, которые на изображении находятся достаточно близко к знаку. Таким образом, если мы будем брать любые области, не пересекающиеся с ROI, то большинство из них будет содержать небо, дорожное покрытие, стены домов и т.п., что негативно отразится на качестве классификации. Всего таких отрицательных прецедентов отберём около 2000, чтобы выборка для обучения Main CNN была сбалансированной.</p>

<p>[примеры положительных и отрицательных прецедентов]</p>

<p>Чтобы улучшить качество распознавания дорожных знаков с помощью Main CNN будем использовать трюк, который является формой boosting’а:</p>

<ol>
  <li>Обучим Main CNN на полученных нами на предыдущем этапе тренировочных данных;</li>
  <li>Определим, на каких отрицательных прецедентах Main CNN ошибается;</li>
  <li>Сформируем из них и положительных прецедентов новую тренировочную выборку;</li>
  <li>Продолжим обучение Main CNN с помощью Fine-tuning, где в качестве начальных весов используются веса, полученные в пункте 1;</li>
  <li>Повторим пункты 1–4 три раза.</li>
</ol>

<p>[примеры новых отрицательных прецедентов]</p>

<p>При обучении SVM на изначальных тренировочных данных Main CNN результаты следующие: F1-score — 0.85, Точность — 0.85.</p>

<p>После тренировки всех частей ансамбля алгоритмов мы можем применить их к тестовым данным. В качестве метрики точности для изображений, содержащих дорожные знаки, возьмём наименьшее евклидово расстояние между векторами, описывающими ROI. Это не самая точная метрика, однако она даёт представление о качестве работы метода. Результаты на тестовых данных (300 изображений): 39.9, число случаев, когда алгоритм не показал ROI, а они есть (False negative): 33, число случаев, когда алгоритм показал ROI, а их нет (False positive): 5. Ниже представлено нескоько характерных примеров работы алгоритма.</p>

<p>Все знаки правильно детектировались:
[2-3 примера]</p>

<p>Довольно часто алгоритм ошибается, принимая такие объекты, как фара машины, за знак:
[пример с фарой]</p>

<p>Иногда алгоритм находит не все знаки:</p>

<p><img src="/images/res_1.jpeg" title="Не все знаки" /></p>

<p>False positive:
[пример false positive]</p>

<h2 id="section-3">Заключение</h2>

<p>Подводя итог, можно сказать, что был разработан несложный, но вполне рабочий алгоритм, основанный на deep learning для детектирования дорожных знаков на изображении. В силу того, что обучение происходило на машине с относительно слабой конфигурацией (8 Гб оперативной памяти, GPU: GeForce 730, 2Гб памяти), увеличение вычислительных мощностей и добавление дополнительных данных приведёт к улучшению качества работы как свёрточной нейронной сети, так и SVM.</p>

<p>В статье мы рассмотрели использование CNN, коснулись ReLU, Pooling, Dropout и других понятий, входящих в такую область машинного обучения, как deep learning. Для того, чтобы больше узнать об этом стремительно набирающем в последние несколько лет популярность направлении, в дальнейшем будет сделан цикл статьей по теории и практике глубоких нейронных сетей, благо название блога обязывает!</p>

<h2 id="section-4">Ссылки</h2>

<ol>
  <li><a href="http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf">Статья с описанием метода команды университета Торонто</a></li>
  <li><a href="http://www.cs.berkeley.edu/~rbg/papers/r-cnn-cvpr.pdf">Regions with CNN features</a></li>
  <li><a href="http://arxiv.org/abs/1312.4400">Network in network</a></li>
  <li><a href="https://github.com/andrewbo29/traffic_signs_detector">Код на github</a></li>
</ol>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Опубликовал <span class="fn">Andrei Boiarov</span></span>

      




<time class='entry-date' datetime='2015-08-16T23:36:02+03:00'><span class='date'>16/08/2015</span> <span class='time'>23:36</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/deep-learning/'>deep learning</a>, <a class='category' href='/blog/categories/komp'iutiernoie-zrieniie/'>Компьютерное зрение</a>, <a class='category' href='/blog/categories/mashinnoie-obuchieniie/'>Машинное обучение</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://datadeep.ru/blog/2015/08/16/dietiektirovaniie-dorozhnykh-znakov-s-pomoshch'iu-deep-learning/" data-via="" data-counturl="http://datadeep.ru/blog/2015/08/16/dietiektirovaniie-dorozhnykh-znakov-s-pomoshch'iu-deep-learning/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
  
    <div id="vk_like"></div>
    <script type="text/javascript">
    window.onload = function () {
        VK.init({apiId: 4631132, onlyWidgets: true});
        VK.Widgets.Like("vk_like", {type: "mini"});
    }
    </script>
  
</div>

    
    <p class="meta">
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Недавние Посты</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/16/dietiektirovaniie-dorozhnykh-znakov-s-pomoshch'iu-deep-learning/">Обнаружение дорожных знаков с помощью Deep Learning</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>Категории</h1>
    <ul id="category-list"><li><a href='/blog/categories/deep-learning'>deep learning (1)</a></li><li><a href='/blog/categories/komp-iutiernoie-zrieniie'>Компьютерное зрение (1)</a></li><li><a href='/blog/categories/mashinnoie-obuchieniie'>Машинное обучение (1)</a></li></ul>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Команда datadeep.ru -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




  <script type="text/javascript" src="//vk.com/js/api/openapi.js?75"></script>




</body>
</html>

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

