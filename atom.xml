<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[DataDeep Evil Twin]]></title>
  <link href="http://datadeep.ru/atom.xml" rel="self"/>
  <link href="http://datadeep.ru/"/>
  <updated>2015-08-19T21:42:52+03:00</updated>
  <id>http://datadeep.ru/</id>
  <author>
    <name><![CDATA[Команда datadeep.ru]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Детектирование дорожных знаков с помощью Deep Learning]]></title>
    <link href="http://datadeep.ru/blog/2015/08/16/dietiektirovaniie-dorozhnykh-znakov-s-pomoshch'iu-deep-learning/"/>
    <updated>2015-08-16T23:36:02+03:00</updated>
    <id>http://datadeep.ru/blog/2015/08/16/dietiektirovaniie-dorozhnykh-znakov-s-pomoshch&#8217;iu-deep-learning</id>
    <content type="html"><![CDATA[<p>Команда блога DataDeep.ru ffff aaa не смогла остаться в стороне от <a href="https://meduza.io/news/2015/07/17/samoupravlyaemaya-mashina-google-popala-v-pervoe-dtp-s-postradavshimi">недавних событий</a>, и поэтому я решил написать пост о своём опыте разработки системы для детектирования дорожных знаков, основанной на машинном обучении, которую можно отнести к компонентам самоуправляемого автомобиля :)</p>

<p><img src="http://datadeep.ru/images/selfdrivingcar.jpg" width="768" height="576" title="Self-driving car" /></p>

<!-- more -->

<h3 id="section">Постановка задачи, описание данных</h3>

<p>Итак, мы хотим сделать приложение, которое будет максимально достоверно находить и выделять рамкой (region of interest, ROI) дорожные знаки на изображении, поступившем на вход. Сердцем метода, решающего эту задачу будет, как не трудно предположить, машинное обучение. Для использования такого подхода необходимы тренировочные данные, в качестве которых будем использовать данные с соревнования <a href="http://benchmark.ini.rub.de/?section=gtsdb&amp;subsection=dataset">The German Traffic Sign Detection Benchmark</a>. Это соревнование по детектированию и определению категории дорожного знака, которое проводилось в 2013 году. Парным к нему является соревнование по распознаванию знаков The German Traffic Sign Recognition Benchmark, в котором алгоритм, построенный на основе глубоких нейронных сетей (deep learning) <a href="http://www.nytimes.com/2012/11/24/science/scientists-see-advances-in-deep-learning-a-part-of-artificial-intelligence.html?_r=0">превзошёл по точности распознавания уровень человека</a>.</p>

<p>Данные представляют собой 900 изображений размером $1360 \times 800$ в формате ppm, а также 1213 изображений дорожных знаков, взятых с этих картинок, размером от $16\times16$ до $128\times128$ в формате ppm.  Некоторые из больших изображений содержат один и более знак, в то время, как другие не содержат знаков вовсе. ROI задаётся с помощью четырёхмерного вектора с координатами прямоугольной рамки <script type="math/tex">(x_{min}, y_{min}, x_{max}, y_{max})</script>. Для всех 900 изображений заданы правильные ROI. Несколько примеров из данных:</p>

<p>Один дорожный знак:</p>

<p><img src="http://datadeep.ru/images/0.jpg" title="Один знак" /></p>

<p>Два знака:</p>

<p><img src="http://datadeep.ru/images/1.jpg" title="Два знака" /></p>

<p>Без знаков:</p>

<p><img src="http://datadeep.ru/images/2.jpg" title="Без знаков" /></p>

<p>Таким образом, наша задача заключается в том, чтобы обучить алгоритм, который для входного изображения будет выдавать 0 или более четырёхмерных векторов по числу обнаруженных дорожных знаков.</p>

<h3 id="state-of-the-art-">Обзор <em>state of the art</em> подходов</h3>

<p>Начиная примерно с 2012 года, когда на очень известном в сообществе computer vision соревновании по распознаванию изображений ImageNet победила команда университета Торонто под руководством Джеффри Хинтона, показав при этом значительный отрыв в точности от других команд, state of the art методом для распознавания изображений считается использование глубоких свёрточных нейронных сетей (Convolutional neural network, CNN), которые, в свою очередь, являются представителем класса алгоритмов машинного обучения deep learning (глубокое или, если угодно, глубинное обучение). Очень многие лучшие на сегодняшний день системы машинного зрения основаны на CNN, например <a href="https://research.facebook.com/publications/480567225376225/deepface-closing-the-gap-to-human-level-performance-in-face-verification/">система распознавания лиц от Facebook</a> (к слову, глава Facebook AI Research Ян Лекун является одним из пионеров в исследовании CNN и deep learning).</p>

<p>В области детектирования предметов на изображении одним из самых эффективных является метод <em>Regions with CNN features</em> или <em>R-CNN</em>, представленный в 2014 году. Этот метод можно разделить на следующие этапы:
1. Определение областей изображения, которые могут содержать интересующие нас объекты, с помощью алгоритма <em>Selective search</em>;
2. Выделение из полученных областей признаков, используя свёрточную нейронную сеть;
3. Эти признаки подаются на вход SVM (Support vectors machine), которая классифицирут объект.</p>

<p>Существуют и другие успешные методы дектирования, основанные на CNN, например <a href="http://arxiv.org/abs/1312.6229">построение регрессии</a> для нахождения четырёхмерного вектора ROI (т.е. на последнем уровне CNN находятся не вероятности, а целые значения). Однако, идея алгоритма, который мы будем строить, вдохновлена в первую очередь R-CNN, благодаря его простоте и эффективности, и реализует три его этапа, хотя имеет ряд значительных отличий.</p>

<h3 id="section-1">Описание метода</h3>

<p>Перед тем, как описать структуру метода для детектирования дорожных знаков на изображении, скажу пару слов о технологиях, которые будут использованы. В качестве языка программирования используется python, так как для него есть API всех необходимых библиотек, и в данном случае нам больше важна гибкость и лёгкость прототипирования, чем скорость работы приложения.</p>

<p>Вся работа со свёрточными нейронными сетями ведётся с помощью изумительной библиотеки <a href="http://caffe.berkeleyvision.org/">Caffe</a>. Она позволяет конструировать, обучать и применять CNN, содержит state of the art виды слоёв и методы тренировки сети, обрабатывает данные в различных форматах (в том числе HDF5), позволяет обучать сети на графическом процессоре (GPU) с использованием CUDA, имеет обёртку для python pycaffe. Для caffe есть хранилище model zoo, в котором содержаться обученные модели, которые можно использовать для своих задач. Также хочется отметить хорошие tutorial и большее сообщество. Архитектура нейронных сетей и параметры метода обучения задаются в caffe в файлах <a href="https://developers.google.com/protocol-buffers/docs/overview">формата prototxt</a>.</p>

<p>Для обработки изображений используется библиотека OpenCV, которая, я думаю, не нуждается в дальнейшем представлении.</p>

<p>Приступим непосредственно к методу решения задачи. На первом этапе будем определять области входного изображения, которые потенциально могут содержать дорожный знак. Для этого было рассмотрено несколько детекторов (в частности selective search из R-CNN, который не смог хорошо выделить области со знаками), и лучше всего себя показал метод <a href="https://en.wikipedia.org/wiki/Maximally_stable_extremal_regions">MSER</a> (maximally stable extremal regions). Из выделенных MSER областей отбирались те, в которых длина и ширина лежат в пределах от 16 до 128 и их соотношение не превышает 1.5 (т.е. более-менее близки по форме к квадрату). Таким образом, мы получаем набор областей, в которых может содержаться один дорожный знак.</p>

<p>На следующем этапе алгоритма для определения того, содержит ли область изображения из предыдущего этапа знак, будем применять классификатор. В этом качестве выступит представитель класса методов deep learning — глубокая свёрточная нейронная сеть. Ей на вход будет поступать изображение, а на выходе будут две вероятности: того, что изображение содержит и не содержит дорожный знак. Архитектура нейронной сети, которую мы будем использовать, сходна c архитектурой весьма эффективной сети <em>Network in network</em> (NIN), которая хорошо себя показала в 2014 году в конкурсе <a href="http://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10</a> (определение, к какой из 10 категорий принадлежит изображение).</p>

<p>На вход нейронная сеть получает RGB изображение размером $32\times32$, которое предварительно преобразуется в такой формат, если нужно. Рассмотрим подробнее слои сети, для этого обозначим CONV — свёрточный слой, RELU — <a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)">Rectified linear unit</a> для нелинейного преобразования данных, POOL — pooling-слой для уменьшения размерности, DROPOUT — dropout-слой для регуляризации. Архитектура сети представляет собой 3 больших последовательно соединённых слоя, каждый из которых состоит из [CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; POOL -&gt; DROPOUT]. На самом последнем слое мы получаем две вероятности. Назовём эту сеть <em>Main CNN</em>. Ниже приведено полное описание сети в формате prototxt, которое применятся для её обучения с помощью Caffe.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (signet_nin_finetune_deploy.html)</span> <a href="http://datadeep.ru/downloads/code/signet_nin_finetune_deploy.html">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
<span class="line-number">104</span>
<span class="line-number">105</span>
<span class="line-number">106</span>
<span class="line-number">107</span>
<span class="line-number">108</span>
<span class="line-number">109</span>
<span class="line-number">110</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
<span class="line-number">113</span>
<span class="line-number">114</span>
<span class="line-number">115</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span>
<span class="line-number">119</span>
<span class="line-number">120</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
<span class="line-number">123</span>
<span class="line-number">124</span>
<span class="line-number">125</span>
<span class="line-number">126</span>
<span class="line-number">127</span>
<span class="line-number">128</span>
<span class="line-number">129</span>
<span class="line-number">130</span>
<span class="line-number">131</span>
<span class="line-number">132</span>
<span class="line-number">133</span>
<span class="line-number">134</span>
<span class="line-number">135</span>
<span class="line-number">136</span>
<span class="line-number">137</span>
<span class="line-number">138</span>
<span class="line-number">139</span>
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>
<span class="line-number">143</span>
<span class="line-number">144</span>
<span class="line-number">145</span>
<span class="line-number">146</span>
<span class="line-number">147</span>
<span class="line-number">148</span>
<span class="line-number">149</span>
<span class="line-number">150</span>
<span class="line-number">151</span>
<span class="line-number">152</span>
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>
<span class="line-number">156</span>
<span class="line-number">157</span>
<span class="line-number">158</span>
<span class="line-number">159</span>
<span class="line-number">160</span>
<span class="line-number">161</span>
<span class="line-number">162</span>
<span class="line-number">163</span>
<span class="line-number">164</span>
<span class="line-number">165</span>
<span class="line-number">166</span>
<span class="line-number">167</span>
<span class="line-number">168</span>
<span class="line-number">169</span>
<span class="line-number">170</span>
<span class="line-number">171</span>
<span class="line-number">172</span>
<span class="line-number">173</span>
<span class="line-number">174</span>
<span class="line-number">175</span>
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>
<span class="line-number">179</span>
<span class="line-number">180</span>
<span class="line-number">181</span>
<span class="line-number">182</span>
<span class="line-number">183</span>
<span class="line-number">184</span>
<span class="line-number">185</span>
<span class="line-number">186</span>
<span class="line-number">187</span>
<span class="line-number">188</span>
<span class="line-number">189</span>
<span class="line-number">190</span>
<span class="line-number">191</span>
<span class="line-number">192</span>
<span class="line-number">193</span>
<span class="line-number">194</span>
<span class="line-number">195</span>
<span class="line-number">196</span>
<span class="line-number">197</span>
<span class="line-number">198</span>
<span class="line-number">199</span>
<span class="line-number">200</span>
<span class="line-number">201</span>
<span class="line-number">202</span>
<span class="line-number">203</span>
<span class="line-number">204</span>
<span class="line-number">205</span>
<span class="line-number">206</span>
<span class="line-number">207</span>
<span class="line-number">208</span>
<span class="line-number">209</span>
<span class="line-number">210</span>
<span class="line-number">211</span>
<span class="line-number">212</span>
<span class="line-number">213</span>
<span class="line-number">214</span>
<span class="line-number">215</span>
<span class="line-number">216</span>
<span class="line-number">217</span>
<span class="line-number">218</span>
<span class="line-number">219</span>
<span class="line-number">220</span>
<span class="line-number">221</span>
<span class="line-number">222</span>
<span class="line-number">223</span>
<span class="line-number">224</span>
<span class="line-number">225</span>
<span class="line-number">226</span>
<span class="line-number">227</span>
<span class="line-number">228</span>
<span class="line-number">229</span>
<span class="line-number">230</span>
<span class="line-number">231</span>
<span class="line-number">232</span>
<span class="line-number">233</span>
<span class="line-number">234</span>
<span class="line-number">235</span>
<span class="line-number">236</span>
<span class="line-number">237</span>
<span class="line-number">238</span>
<span class="line-number">239</span>
<span class="line-number">240</span>
<span class="line-number">241</span>
<span class="line-number">242</span>
<span class="line-number">243</span>
<span class="line-number">244</span>
<span class="line-number">245</span>
<span class="line-number">246</span>
<span class="line-number">247</span>
<span class="line-number">248</span>
<span class="line-number">249</span>
<span class="line-number">250</span>
<span class="line-number">251</span>
<span class="line-number">252</span>
<span class="line-number">253</span>
<span class="line-number">254</span>
<span class="line-number">255</span>
<span class="line-number">256</span>
<span class="line-number">257</span>
<span class="line-number">258</span>
<span class="line-number">259</span>
<span class="line-number">260</span>
<span class="line-number">261</span>
<span class="line-number">262</span>
<span class="line-number">263</span>
<span class="line-number">264</span>
<span class="line-number">265</span>
<span class="line-number">266</span>
<span class="line-number">267</span>
<span class="line-number">268</span>
<span class="line-number">269</span>
<span class="line-number">270</span>
<span class="line-number">271</span>
<span class="line-number">272</span>
<span class="line-number">273</span>
<span class="line-number">274</span>
<span class="line-number">275</span>
<span class="line-number">276</span>
<span class="line-number">277</span>
<span class="line-number">278</span>
<span class="line-number">279</span>
<span class="line-number">280</span>
<span class="line-number">281</span>
<span class="line-number">282</span>
<span class="line-number">283</span>
<span class="line-number">284</span>
<span class="line-number">285</span>
<span class="line-number">286</span>
<span class="line-number">287</span>
<span class="line-number">288</span>
<span class="line-number">289</span>
<span class="line-number">290</span>
<span class="line-number">291</span>
<span class="line-number">292</span>
<span class="line-number">293</span>
<span class="line-number">294</span>
<span class="line-number">295</span>
<span class="line-number">296</span>
<span class="line-number">297</span>
<span class="line-number">298</span>
<span class="line-number">299</span>
<span class="line-number">300</span>
<span class="line-number">301</span>
<span class="line-number">302</span>
<span class="line-number">303</span>
<span class="line-number">304</span>
<span class="line-number">305</span>
<span class="line-number">306</span>
<span class="line-number">307</span>
<span class="line-number">308</span>
<span class="line-number">309</span>
<span class="line-number">310</span>
<span class="line-number">311</span>
<span class="line-number">312</span>
<span class="line-number">313</span>
<span class="line-number">314</span>
<span class="line-number">315</span>
<span class="line-number">316</span>
<span class="line-number">317</span>
<span class="line-number">318</span>
<span class="line-number">319</span>
<span class="line-number">320</span>
<span class="line-number">321</span>
</pre></td><td class="code"><pre><code class="html"><span class="line">name: &quot;SigNet_NIN_FineTune_Deploy&quot;
</span><span class="line">input: &quot;data&quot;
</span><span class="line">input_dim: 1
</span><span class="line">input_dim: 3
</span><span class="line">input_dim: 32
</span><span class="line">input_dim: 32
</span><span class="line">layers {
</span><span class="line">  name: &quot;conv1&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;data&quot;
</span><span class="line">  top: &quot;conv1&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1.
</span><span class="line">  weight_decay: 0.
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    pad: 2
</span><span class="line">    kernel_size: 5
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu1&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;conv1&quot;
</span><span class="line">  top: &quot;conv1&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp1&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;conv1&quot;
</span><span class="line">  top: &quot;cccp1&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 160
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp1&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp1&quot;
</span><span class="line">  top: &quot;cccp1&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp2&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;cccp1&quot;
</span><span class="line">  top: &quot;cccp2&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 96
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp2&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp2&quot;
</span><span class="line">  top: &quot;cccp2&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;pool1&quot;
</span><span class="line">  type: POOLING
</span><span class="line">  bottom: &quot;cccp2&quot;
</span><span class="line">  top: &quot;pool1&quot;
</span><span class="line">  pooling_param {
</span><span class="line">    pool: MAX
</span><span class="line">    kernel_size: 3
</span><span class="line">    stride: 2
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;drop3&quot;
</span><span class="line">  type: DROPOUT
</span><span class="line">  bottom: &quot;pool1&quot;
</span><span class="line">  top: &quot;pool1&quot;
</span><span class="line">  dropout_param {
</span><span class="line">    dropout_ratio: 0.5
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;conv2&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;pool1&quot;
</span><span class="line">  top: &quot;conv2&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1.
</span><span class="line">  weight_decay: 0.
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    pad: 2
</span><span class="line">    kernel_size: 5
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu2&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;conv2&quot;
</span><span class="line">  top: &quot;conv2&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp3&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;conv2&quot;
</span><span class="line">  top: &quot;cccp3&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp3&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp3&quot;
</span><span class="line">  top: &quot;cccp3&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp4&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;cccp3&quot;
</span><span class="line">  top: &quot;cccp4&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp4&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp4&quot;
</span><span class="line">  top: &quot;cccp4&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;pool2&quot;
</span><span class="line">  type: POOLING
</span><span class="line">  bottom: &quot;cccp4&quot;
</span><span class="line">  top: &quot;pool2&quot;
</span><span class="line">  pooling_param {
</span><span class="line">    pool: AVE
</span><span class="line">    kernel_size: 3
</span><span class="line">    stride: 2
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;drop6&quot;
</span><span class="line">  type: DROPOUT
</span><span class="line">  bottom: &quot;pool2&quot;
</span><span class="line">  top: &quot;pool2&quot;
</span><span class="line">  dropout_param {
</span><span class="line">    dropout_ratio: 0.5
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;conv3&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;pool2&quot;
</span><span class="line">  top: &quot;conv3&quot;
</span><span class="line">  blobs_lr: 1.
</span><span class="line">  blobs_lr: 2.
</span><span class="line">  weight_decay: 1.
</span><span class="line">  weight_decay: 0.
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    pad: 1
</span><span class="line">    kernel_size: 3
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu3&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;conv3&quot;
</span><span class="line">  top: &quot;conv3&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp5&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;conv3&quot;
</span><span class="line">  top: &quot;cccp5&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 2
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 192
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp5&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp5&quot;
</span><span class="line">  top: &quot;cccp5&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;cccp6_signet&quot;
</span><span class="line">  type: CONVOLUTION
</span><span class="line">  bottom: &quot;cccp5&quot;
</span><span class="line">  top: &quot;cccp6_signet&quot;
</span><span class="line">  blobs_lr: 1
</span><span class="line">  blobs_lr: 1
</span><span class="line">  weight_decay: 1
</span><span class="line">  weight_decay: 0
</span><span class="line">  convolution_param {
</span><span class="line">    num_output: 2
</span><span class="line">    group: 1
</span><span class="line">    kernel_size: 1
</span><span class="line">    weight_filler {
</span><span class="line">      type: &quot;gaussian&quot;
</span><span class="line">      std: 0.05
</span><span class="line">    }
</span><span class="line">    bias_filler {
</span><span class="line">      type: &quot;constant&quot;
</span><span class="line">      value: 0
</span><span class="line">    }
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;relu_cccp6_signet&quot;
</span><span class="line">  type: RELU
</span><span class="line">  bottom: &quot;cccp6_signet&quot;
</span><span class="line">  top: &quot;cccp6_signet&quot;
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;pool3_signet&quot;
</span><span class="line">  type: POOLING
</span><span class="line">  bottom: &quot;cccp6_signet&quot;
</span><span class="line">  top: &quot;pool3_signet&quot;
</span><span class="line">  pooling_param {
</span><span class="line">    pool: AVE
</span><span class="line">    kernel_size: 8
</span><span class="line">    stride: 1
</span><span class="line">  }
</span><span class="line">}
</span><span class="line">layers {
</span><span class="line">  name: &quot;prob&quot;
</span><span class="line">  type: SOFTMAX
</span><span class="line">  bottom: &quot;pool3_signet&quot;
</span><span class="line">  top: &quot;prob&quot;
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Для того, чтобы обучить всё эту сеть будем использовать стандартный метод оптимизации Batch stochastic gradient descent с уменьшением параметра learning rate в 10 раз каждые 1000 шагов, начальный learning rate — 0.000001. Кроме того, применим метод Momentum Нестерова с параметром 0.9. В качестве регуляризации будем использовать Weight decay с параметром 0.0001. Prototxt файл со всеми параметрами оптимизации, который используется в Caffe:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (signet_nin_finetune_solver.html)</span> <a href="http://datadeep.ru/downloads/code/signet_nin_finetune_solver.html">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="html"><span class="line">net: &quot;/home/andrew/Projects/GTSDB/mark_III/model/signet_nin_finetune_train_val.prototxt&quot;
</span><span class="line">test_iter: 100
</span><span class="line">test_interval: 1000
</span><span class="line">base_lr: 0.000001
</span><span class="line">momentum: 0.9
</span><span class="line">weight_decay: 0.0001
</span><span class="line">lr_policy: &quot;step&quot;
</span><span class="line">gamma: 0.1
</span><span class="line">stepsize: 1000
</span><span class="line">display: 100
</span><span class="line">max_iter: 50000
</span><span class="line">snapshot: 1000
</span><span class="line">snapshot_prefix: &quot;/home/andrew/Projects/GTSDB/mark_III/model/caffemodel/signet_nin_finetune_finetune_3&quot;
</span><span class="line">solver_mode: GPU
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Для ускорения обучения будем применять подход <em>Fine-tuning</em>: веса нейронной сети инициализируются предобученными для другой (но похожей) задачи. Мы используем веса, которые были обучены авторами NIN для задачи CIFAR-10.</p>

<p>Итак, с помощью описанной выше CNN мы отберём области изображения, скорее всего содержащие знак (т.е. те, для которых вероятность наличия знака, выданная сетью, больше порога 0.5). Для того, чтобы улучшить качество распознавания, построим поверх нейронной сети ещё один классификатор. Для этого будем использовать CNN, аналогичную той, которую мы уже построили, только без последнего слоя вероятностей. Если посмотреть на параметры в описании архитектуры используемой CNN, то от туда можно понять, что новая сеть будет выдавать на выходе вектор размерности 128. Назовём её <em>Features learning CNN</em>. В качестве весов она использует натренированные веса Main CNN. Features learning CNN мы будем применять к областям изображений, которые по мнению Main CNN содержат дорожный знак.  Мы получим 128-размерный вектор признаков, который будем “скармливать” машине опорных векторов (SVM) с полиномиальным ядром степени 2 и параметром регуляризации 0.1. Таким образом, полный алгоритм представляет собой ансамбль: MSER -&gt; Main CNN -&gt; Features learning CNN -&gt; SVM.</p>

<p>Для того, чтобы нарисовать ROI, содержащую дорожный знак, нам остался ещё один шаг. В силу особенностей метода MSER может получиться ситуация, когда для одного знака получается несколько очень близко расположенных рамок (т.е. областей изображения, отобранных на предыдущем этапе). Объединив такие рамки в одну (взяв наибольшую из них), мы получим финальный ROI.</p>

<h3 id="section-2">Применение метода</h3>

<p>Теперь опишем то, как обучался алгоритм и что из этого вышло. Прежде всего, нам необходимы тренировочные данные для Main CNN. Разделим имеющиеся в нашем распоряжении 900 изображений на 600 тренировочных и 300 тестовых. В исходных данных уже есть изображения дорожных знаков, т.е. положительные прецеденты, однако нет отрицательных, т.е. изображений без знаков. Для того, чтобы получить эти данные, используем следующую процедуру: к каждому изображению из тренировочных данных применяется MSER и отбираются те его области, которые похожи по размерам на ROI (см. выше), не пересекаются с настоящим ROI, но при этом лежат относительно “не далеко” от него. Последний пункт нужен, т.к. CNN будет хорошо “отличать” дорожный знак от, например, неба или асфальта, но плохо от окна, фары машины, листвы и т.д., т.е. от объектов, которые на изображении находятся достаточно близко к знаку. Кроме того, если мы будем брать любые области, не пересекающиеся с ROI, то большинство из них будет содержать небо, дорожное покрытие, стены домов и т.п., что негативно отразится на качестве классификации. Всего таких отрицательных прецедентов отберём около 2000, чтобы выборка для обучения Main CNN была сбалансированной.</p>

<p>[примеры положительных и отрицательных прецедентов]</p>

<p>Чтобы улучшить качество распознавания дорожных знаков с помощью Main CNN будем использовать трюк, который является формой boosting’а:
1. Обучим Main CNN на полученных нами тренировочных данных;
2. Определим, на каких отрицательных прецедентах Main CNN ошибается;
3. Сформируем из них и положительных прецендентов новую тренировочную выборку;
4. Продолжим обучение Main CNN с помощью Fine-tuning, где в качестве начальных весов используются веса, полученные в пункте 1;
5. Повторим пункты 1–4 три раза.</p>

<p>[примеры новых отрицательных прецедентов]</p>

<p>При обучении SVM на изначальных тренировочных данных Main CNN результаты следующие: F1-score — 0.85, Точность — 0.85.</p>

<p>После тренировки всех частей ансамбля алгоритмов мы можем применить их к тестовым данным. В качестве метрики точности для изображений, содержащих дорожные знаки, возьмём наименьшее евклидово расстояние между векторами, описывающими ROI. Это не самая точная метрика, однако она даёт представление о качестве работы метода. Результаты на тестовых данных (300 изображений): 39.9, число случаев, когда алгоритм не показал ROI, а они есть (False negative): 33, число случаев, когда алгоритм показал ROI, а их нет (False positive): 5. Ниже представлено нескоько характерных примеров работы алгоритма.</p>

<p>Все знаки правильно детектировались:
[2-3 примера]</p>

<p>Довольно часто алгоритм ошибается, принимая такие объекты, как фара машины, за знак:
[пример с фарой]</p>

<p>Иногда алгоритм находит не все знаки:</p>

<p><img src="http://datadeep.ru/images/res_1.jpeg" title="Не все знаки" /></p>

<p>False positive:
[пример false positive]</p>

<h3 id="section-3">Заключение</h3>

<p>Подводя итог, можно сказать, что мы разработали несложный, но вполне рабочий алгоритм, основанный на deep learning для детектирования дорожных знаков на изображении. В силу того, что обучение происходило на машине с относительно слабой конфигурацией (8 Гб оперативной памяти, GPU: GeForce 730, 2Гб памяти), увеличение вычислительных мощностей и добавление дополнительных данных приведёт к улучшению качества работы как свёрточной нейронной сети, так и SVM.</p>

<p>В статье мы рассмотрели использование CNN, коснулись ReLU, Pooling, Dropout и других вещей, входящих в такую область машинного обучения, как deep learning.<br />
Для того, чтобы больше узнать об этом стремительно набирающем в последние несколько лет популярность направлении, в дальнейшем будет сделан цикл статьей по теории и практике глубоких нейронных сетей, благо название блога обязывает!</p>

<h3 id="section-4">Ссылки</h3>
<ol>
  <li><a href="http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf">Статья с описанием метода команды университета Торонто</a></li>
  <li><a href="http://www.cs.berkeley.edu/~rbg/papers/r-cnn-cvpr.pdf">Regions with CNN features</a></li>
  <li><a href="http://arxiv.org/abs/1312.4400">Network in network</a></li>
  <li><a href="https://github.com/andrewbo29/traffic_signs_detector">Код на github</a></li>
</ol>
]]></content>
  </entry>
  
</feed>
